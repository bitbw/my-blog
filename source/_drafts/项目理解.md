原始数据库对象通过database获取的 挂载在DB对象的connections 的connection下

![image-20200923160153652](C:\E盘资料\my-blog\my-blog\source\_drafts\项目理解\image-20200923160153652.png)

```js
{
  "open": true,
  "filename": "C:\\Users\\WX03\\iConfig\\iconfig_sys.config",
  "mode": 2
   //原型方法
    {
        addListener: ƒ (type)
        all: ƒ ()
        backup: ƒ ()
        close: ƒ () //关闭连接
        configure: ƒ configure()
        each: ƒ ()
        emit: ƒ emit(type, ...args)
        eventNames: ƒ eventNames()
        exec: ƒ ()
        get: ƒ ()
        getMaxListeners: ƒ getMaxListeners()
        interrupt: ƒ interrupt()
        listenerCount: ƒ listenerCount(type)
        listeners: ƒ listeners(type)
        loadExtension: ƒ loadExtension()
        map: ƒ ()
        off: ƒ removeListener(type, listener)
        on: ƒ (type)
        once: ƒ once(type, listener)
        parallelize: ƒ parallelize()
        prepare: ƒ ()
        prependListener: ƒ prependListener(type, listener)
        prependOnceListener: ƒ prependOnceListener(type, listener)
        rawListeners: ƒ rawListeners(type)
        removeAllListeners: ƒ (type)
        removeListener: ƒ (type)
        run: ƒ ()
        serialize: ƒ serialize()
        setMaxListeners: ƒ setMaxListeners(n)
        wait: ƒ wait()
        _events: undefined
        _eventsCount: 0
        _maxListeners: undefined
    }
}
```



数据库对象的属性和方法  DB 通过DB类生成

```js
{
  "dbPath": "C:\\ls-project02\\app\\file\\init\\iconfig_user.config",
  "lock": false,
  "logger": {
    "group": "DB",
    "options": {
      "i18n": "en-US",
      "level": 1,
      "output": {
        "memory": {}
      },
      "append": ""
    }
  },
  "connections": null,
  "options": {
    "timeout": 0,
    "poolsize": 8,
    "loglevel": "info",
    "secret": "IPS@@@IPS@@@DB"
  }
  
}
//原型方法
{
    exec: ƒ exec(_x)
    exists: ƒ exists()
    getConnection: ƒ getConnection()
    newConnection: ƒ newConnection()
    parseOptions: ƒ parseOptions(options)
    parseWhere: ƒ parseWhere(obj)
    table: ƒ table(tablename)
    update: ƒ update()
    wait: ƒ wait()
}
```

假设全局只有两个数据库对象

# 项目启动

### electron API

https://blog.csdn.net/k157507281/article/details/99415263

![在这里插入图片描述](C:\E盘资料\my-blog\my-blog\source\_drafts\项目理解\aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS82LzEwLzE2YjNkMWM5ZDJlMjJhNGE)

###  sqliste3-API  

 https://github.com/mapbox/node-sqlite3/wiki/API

![image-20200923144912093](C:\Users\WX03\AppData\Roaming\Typora\typora-user-images\image-20200923144912093.png)

## main.js

```js
import Vue from 'vue';
import store from './plugins/vuex';
import router from './plugins/router';
import vuetify from './plugins/vuetify';
import i18n from './plugins/i18n';

import App from './App.vue';
import LaunchPage from './Launch.vue';
import ErrorPage from './Error.vue';

import { Delay } from '@/util/func';
import fs from 'fs';
import path from 'path';
import { userDB, dbPath, openDB } from '@/api';
import UpdateFrom from './update';
import { remote } from 'electron';

import Test from './test';

// import common from './../src/static/common_js/common'

Vue.config.productionTip = false;

const dev = process.env.NODE_ENV !== 'production';

if (dev) {
  window.DebugTest = Test;
}

const delay = new Delay(3500); //创建一个3.5秒的延时

const main = () => {
  Check()
    .then(result => showApp())
    .catch(result => showError());
};

// Vue.use(common)

async function Check() {
  try {
    // check if db exist
    // 判断 数据库 是否已经存在
    if (!userDB.exists()) {
      // load first launch page
      // 加载首次启动页面
      showLaunch();
      // create db
      // 创建数据库
      await createDB();
      // relaunch app when create action finish
      // 创建数据库完成重新启动项目
      remote.app.relaunch();
      // 生产环境 执行一下退出操作
      if (!dev) remote.app.quit();
    }
    // check version when db is ready, first db is packed from exe file, maybe out of date
    let versionRow = await userDB
      .table('t_local_setting')
      .where('key_name="version"')
      .findOne();
    let nowVersionRow = await openDB(path.join(process.cwd(), 'file/init/iconfig_user.config'))
      .table('t_local_setting')
      .where('key_name="version"')
      .findOne();
    // :TODO check online version
    // 查看当前版本号与本地版本号是否一致
    if (versionRow.key_value === nowVersionRow.key_value) return true;
    //不一致 则 更新数据
    else {
      showLaunch();
      // 调用更新本地数据库方法
      await delay.run(updateApp(versionRow.key_value, nowVersionRow.key_value));
      remote.app.relaunch();
      // 生产环境 执行一下退出操作
      if (!dev) remote.app.quit();
    }
  } catch (error) {
    console.log(error);
    return false;
  }
}
async function createDB() {
  // 从file目录拷贝到本地目录
  let copy = async () => {
    let files = [
      'e950.rule',
      's914.rule',
      's920.rule',
      's922.rule',
      's924.rule',
      'iconfig_sys.config',
      'iconfig_user.config',
    ];
    try {
      //创建目录
      fs.mkdirSync(dbPath);
    } catch (error) {
      console.log('exist');
    }
    files.forEach(file => {
      let data = fs.readFileSync(path.join(process.cwd(), 'file/init', file));
      fs.writeFileSync(path.join(dbPath, file), data);
    });
    return true;
  };
  return delay.run(copy());
}

async function updateApp(from, to) {
  await UpdateFrom(from, to);
  return true;
}

const showApp = () => {
  new Vue({
    store,
    router,
    vuetify,
    i18n,
    render: h => h(App),
  }).$mount('#app');
};

const showLaunch = () => {
  new Vue({
    vuetify,
    render: h => h(LaunchPage),
  }).$mount('#app');
};

const showError = () => {
  new Vue({
    vuetify,
    render: h => h(ErrorPage),
  }).$mount('#app');
};

// Main

main();

```

## app.vue

```
     //在数据库中取出数据并更新
    this.LoadingSettings();
    this.LoadingProducts();
    this.LoadingPersons();
    this.LoadingCustomer();
```

###  this.LoadingSettings();

以上方法定义在 vuex中

src\plugins\store\global.js

```js
  LoadingSettings: ({ dispatch, commit }) => {
    commit('startLoadSettings')
    delay.run(api.setting.getAll())
      .then(res => commit('updateSettings', res))
      .catch(error => dispatch('SendError', error, { root: true }))
      .finally(() => commit('finishLoadSettings'))
  },
```

api.setting在src\api\global\setting.js中

```js
import { userDB } from '../index'

export default {
  getAll: () => userDB.table('t_local_setting').findAll(),
  post: (obj) => userDB.table('t_local_setting').insert(obj),
  put: (obj) => userDB.table('t_local_setting').update(obj),
}
```

返回 t_local_setting

![image-20200923114843141](C:\Users\WX03\AppData\Roaming\Typora\typora-user-images\image-20200923114843141.png)



###  this.LoadingPersons();

以上方法定义在 vuex中

src\plugins\store\public.js

```js
 LoadingPersons: ({ dispatch, commit }) => {
    commit('startLoadPersons')
    delay.run(api.person.getAll())
      .then(res => commit('updatePersons', res))
      .catch(error => dispatch('SendError', error, { root: true }))
      .finally(() => commit('finishLoadPersons'))
  }
```

api.person  在 src\api\public\person.js 目前是写死的  数据库中没数据

```js
 getAll: () => {
    // return userDB.table('t_person_info').findAll()
    return [
      { "id": 1, "personID": "1", "nameCHN": "销售小明", "nameENG": "xiaoming", "type": "sales", "status": 0 },
      { "id": 2, "personID": "2", "nameCHN": "销售小红", "nameENG": "xiaohong", "type": "sales", "status": 0 },
      { "id": 3, "personID": "3", "nameCHN": "技术小李", "nameENG": "xiaoli", "type": "technical", "status": 0 },
      { "id": 4, "personID": "4", "nameCHN": "技术小李", "nameENG": "xiaowang", "type": "technical", "status": 0 }
    ]
  }
```

### this.LoadingCustomer();

src\plugins\store\public.js

```js
  LoadingCustomer: ({ dispatch, commit }) => {
    commit('startLoadCustomer')
    delay.run(api.customer.getAll())
      .then(res => commit('updateCustomer', res))
      .catch(error => dispatch('SendError', error, { root: true }))
      .finally(() => commit('finishLoadCustomer'))
  },
```

 api.customer 在 src\api\public\customer.js 目前也是写死的 数据库中没数据

```js
  getAll: () => {
    // return userDB.table('t_customer_info').findAll()
    return [
      { "id": 1, "customerID": "1", "crmID": "1", "nameCHN": "移动", "nameENG": "CMCC", "status": 0 },
      { "id": 2, "customerID": "2", "crmID": "2", "nameCHN": "联通", "nameENG": "UNICOM", "status": 0 },
      { "id": 3, "customerID": "3", "crmID": "3", "nameCHN": "工行", "nameENG": "ICBC", "status": 0 },
      { "id": 4, "customerID": "4", "crmID": "4", "nameCHN": "农行", "nameENG": "ABC", "status": 0 }
    ]
  }
```

###  this.LoadingProducts();

以上方法定义在 vuex中

@\plugins\store\configurator.js

```js
 LoadingProducts: ({ dispatch, commit }) => {
    dispatch('ClearProduct')
    commit('startLoadProducts')
    delay.run(api.product.getAll())
      .then(res => commit('updateProducts', res))
      .catch(error => dispatch('SendError', error, { root: true }))
      .finally(() => commit('finishLoadProducts'))
  },
```

api.product  核心定义在@/api/configurator/engine.js   （api的index.js 是挂载所有数据库的核心 @/util/db的DB在这里实例化）

```js
const configuratorEngine = NewConfigurator({
  // :TODO
  sysDBPath: sysDBPath,
  userDBPath: userDBPath,
  secret: secret,
  loglevel: dev ? 'info' : 'error'
})

export default configuratorEngine

```

engine.js  的核心方法NewConfigurator定义在@/util/configurator/index.js中

```js
// Configurator类中的
  async GetProducts() {
    return await this._API.sysDB
      .table('t_def_product_info')
      .where('status=0')
      .findAll();
 }
```

返回数据库内容

![image-20200923101955880](C:\Users\WX03\AppData\Roaming\Typora\typora-user-images\image-20200923101955880.png)

放到vux的products中

## 数据库相关

方案信息储存在 t_schema_info 用于这里的展示和导出    用于联查产品信息的表的id是`schemaID`

![image-20200928163103055](C:\Users\WX03\Desktop\张博文记录\项目理解\image-20200928163103055.png)

t_schema_info 使用 jion   联查 t_schema_product_list   利用`t_schema_info.schemaID = t_schema_product_list.schemaID`

t_schema_product_list    联查  t_config_info   利用  t_schema_product_list.configID = t_config_info.configID  再去找对应的id

```sql
 SELECT *, t_schema_product_list.id FROM t_schema_product_list JOIN t_schema_info ON t_schema_info.schemaID = t_schema_product_list.schemaID JOIN t_config_info ON t_schema_product_list.configID = t_config_info.configID WHERE t_schema_info.schemaID="2bddfed9-df64-4810-866a-049da45861da
```

t_schema_product_list    是中间的跳板 放着schemaID  和 configID  一 一对应

t_config_info  存放着对应configID 基本产品信息  ，而具体的配置信息在t_config_component表中

![image-20200928164251136](C:\Users\WX03\Desktop\张博文记录\项目理解\image-20200928164251136.png)

t_config_component 表中存着所有的配置信息，用于改配和导出  ， 通过configID关联t_config_info 表

## 导入IPC

1. productList.vue 调用@/util/export中的ImportIPC方法返回importTemp

   ```js
   {
     id: 1,
     schemaID: '2bddfed9-df64-4810-866a-049da45861da',
     configID: '3f96b6ee-a111-4dc2-8e79-1fd751f0f4cf',
     status: 0,
     schemaName: '张test',
     customerID: null,
     salesID: null,
     technicalID: null,
     customerName: '张博文',
     salesName: '张博文1',
     technicalName: '张博文2',
     createDate: 1600740278,
     visitDate: 1600744952,
     description: '张博文2张博文2张博文2张博文2',
     shipDate: '2020-09-19',
     mesConfigID: '',
     nameCHN: 'K1_Power_E950',
     nameENG: 'K1_Power_E950',
     descriptionCHN:
       'K1 Power E950 企业级Unix服务器;紧凑的4路系统 可提供卓越的性能 极高的敏捷性和业界领先的可靠性;主要配置如下：;配置 2 × 8核心 3.6GHz主频 POWER9 处理器, 激活16核;配置总计384GB容量企业级内存, 激活384GB; 配置 24×16GB DDR4 企业级内存;配置 4*NVMe 通用存储背板;配置总计1600GB硬盘容量; 配置 2×800GB 主流级U.2固态硬盘; 配置 1×1Gb 4端口 网卡;配置 4×2000W企业级服务器电源;配置 4×K1 Power E950标准电源线;配置 指定语言-简体中文（PRC）;',
     descriptionENG:
       'K1 Power E950 Enterprise Unix Server;Critical server;The major configuration is as below;Configure 2 × 8-core Typical 3.6 to 3.8 GHZ , 16 cores activated;Configure total 384GB enterprise memory, 384GB memory activated;Configure 24×16 GB DDR4 Memory;Configure Storage Backplane with Zero DASD 8 SAS 2.5" HDD/SDD Controllers;Configure total 1600GB enterprise disk Capacity; Configure 2×Mainstream 800 GB SSD NVMe U.2 module; Configure 1×PCIe2 4-port 1GbE Adapter;Configure 4×Power Supply - 2000W for Server ;Configure 4×Power Cord To PDU/UPS, ;Configure Language Group Specify - Simplified Chinese ;',
     type: 'SERVER',
     category: 'K1 Power',
     quantity: 1,
     baseInformation: null,
     listpriceHWUSD: 5255588,
     listpriceHWRMB: 39416910,
     listpriceSWUSD: 153300,
     listpriceSWRMB: 1149750,
     listpriceSVUSD: 0,
     listpriceSVRMB: 0,
     serverModel: '9040-MR9',
     serverName: 'K1 Power E950',
     serverPN: 'FUH-9040MR9-0000',
     serverCategory: 'K1 Power',
     discountHW: 0,
     discountSW: 0,
     discountSV: 0,
     priceVersion: 1,
     version: 1,
     components: [
       {
         id: 1,
         PNCode: '9040-MR9',
         FCCode: '9040-MR9',
         uuid: 'b67985e4-b931-43c4-94a8-72fe6cc58da2',
         nameCHN: 'K1 Power E950',
         nameENG: 'K1 Power E950',
         configID: '3f96b6ee-a111-4dc2-8e79-1fd751f0f4cf',
         type: 'FC_MODEL',
         subType: 'Machine',
         quantity: 1,
         cfgType: '',
         placeDef: '',
         placeGroup: '',
         serverModel: '9040-MR9',
         serverName: 'K1 Power E950',
         serverPN: 'FUH-9040MR9-0000',
         serverCategory: 'K1 Power',
         listpriceUSD: 442000,
         listpriceRMB: 3315000,
         discountUSD: 0,
         discountRMB: 0,
         priceVersion: 1,
         version: 1,
         status: 0,
       },
         // 大概50个左右
     ],
   };
   ```

2. 确定导入handleImportIPC方法  生成importConfig对象

   ```js
   {
     name: 'K1_Power_E950',
     descriptionCHN:
       'K1 Power E950 企业级Unix服务器;紧凑的4路系统 可提供卓越的性能 极高的敏捷性和业界领先的可靠性;主要配置如下：;配置 2 × 8核心 3.6GHz主频 POWER9 处理器, 激活16核;配置总计384GB容量企业级内存, 激活384GB; 配置 24×16GB DDR4 企业级内存;配置 4*NVMe 通用存储背板;配置总计1600GB硬盘容量; 配置 2×800GB 主流级U.2固态硬盘; 配置 1×1Gb 4端口 网卡;配置 4×2000W企业级服务器电源;配置 4×K1 Power E950标准电源线;配置 指定语言-简体中文（PRC）;',
     descriptionENG:
       'K1 Power E950 Enterprise Unix Server;Critical server;The major configuration is as below;Configure 2 × 8-core Typical 3.6 to 3.8 GHZ , 16 cores activated;Configure total 384GB enterprise memory, 384GB memory activated;Configure 24×16 GB DDR4 Memory;Configure Storage Backplane with Zero DASD 8 SAS 2.5" HDD/SDD Controllers;Configure total 1600GB enterprise disk Capacity; Configure 2×Mainstream 800 GB SSD NVMe U.2 module; Configure 1×PCIe2 4-port 1GbE Adapter;Configure 4×Power Supply - 2000W for Server ;Configure 4×Power Cord To PDU/UPS, ;Configure Language Group Specify - Simplified Chinese ;',
     quantity: 1,
     solution: {
       schemaID: '4e1444a2-066d-474f-b542-70185e19c443',
     },
     componentList: [
       {
         FCCode: '9040-MR9',
         PNCode: '9040-MR9',
         cfgType: '',
         discountRMB: 0,
         discountUSD: 0,
         listpriceRMB: 3315000,
         listpriceUSD: 442000,
         nameCHN: 'K1 Power E950',
         nameENG: 'K1 Power E950',
         placeDef: '',
         placeGroup: '',
         quantity: 1,
         serverCategory: 'K1 Power',
         serverModel: '9040-MR9',
         serverName: 'K1 Power E950',
         serverPN: 'FUH-9040MR9-0000',
         status: 0,
         subType: 'Machine',
         type: 'FC_MODEL',
         uuid: 'b3fa3790-9a19-47a1-83e0-0ae42f30da07', //对应表中的configID和schemaID
         version: 1,
       },
     ],
   };
   ```

3. 点击保存调用handleDoImport 方法 内部调用api.configurator.saveConfig(this.importConfig)方法

   api 实际调用 src\util\configurator\index.js 生成Configurator类 中的SaveConfig 方法

   生成config 保存在t_config_info表

   生成list保存在t_config_component

   生成对应的temp 保存在t_schema_product_list

> 以上是新建的 更新和update则是对应的更新schemaID和configID对应的数据

#### 关于ipc

> ipc实际上是包含_d_i_p_s_c_,和_d_i_p_s_m_两个文件的压缩包

#### ImportIPC的操作

JSZip.loadAsync-》加载zip文件， 

zip.files['_d_i_p_s_c_'].async('string')-》获取_d_i_p_s_c_文件的字符串

convert.Decode(cfr)-》先用toStr() 方法将文件字符串转为buffer对象，再使用toString方法转为utf-8的字符串-》传入decode解码

decode(inputString)-》这里需要先说下编码的过程  ，而解码就是反向的编码。

### 导出IPC

ExportMachineIPC 方法接收machine -》findDad(machine)-》从数据库里从新查一遍再拼接一个machine数据

GenIPCFile方法接收参数machine :  

```js
async function GenIPCFile(data) { // machine
  let convert = new Convert()
  let zip = new JSZip();
  if (typeof data === 'object') {
    let cfr = new CFR();
    cfr.ParseMachine(data); //转化cfr对象 {body,footer,header}
     // 这里创建了两个经过编码的文件
    zip.file(`_d_i_p_s_c_`, convert.Encode(cfr.Print()), { binary: true });
    zip.file(`_d_i_p_s_m_`, convert.Encode(JSON.stringify(data)), { binary: true });
    // 创建压缩文件的blob对象 接下来调用SaveAs方法下载
    return await zip.generateAsync({ type: "blob", mimeType: "application/ipc" })
  } else if (typeof data === 'string') {
    zip.file(`_d_i_p_s_c_`, convert.Encode(data), { binary: true });
    return await zip.generateAsync({ type: "blob", mimeType: "application/ipc" })
  }
}
```

Encode方法

```js
 // 第一步编码：使用encodeURIComponent对cfr字符串编码        再传入encode方法
Encode(inputString) { return toBinary(this.encode(encodeURIComponent(inputString))) }
// 第四步编码：使用Buffer.alloc转化 buffer对象 添加%再转字符串
const toBinary = (str) => {
  return Buffer.alloc(str.length, str).join('%') // 转化为Buffer对象(ArrayBuffer)再用%拼接成字符串
}
```

encode方法

```js
encode(inputString) {
    let output = ''
    let chr1, chr2, chr3, enc1, enc2, enc3, enc4
    let i = 0
    inputString = utf8Encode(inputString)
    // 第三步编码： 进行2进制的位移和 且或
    while (i < inputString.length) {
      chr1 = inputString.charCodeAt(i++)
      chr2 = inputString.charCodeAt(i++)
      chr3 = inputString.charCodeAt(i++)
      enc1 = chr1 >> 2
      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4)
      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6)
      enc4 = chr3 & 63
      if (isNaN(chr2)) {
        enc3 = enc4 = 64
      } else if (isNaN(chr3)) {
        enc4 = 64
      }
      output = output +
        this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
        this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4)
    }
    return output  // 返回编码后的结果(MDAzMTIwMjAxMDIzQ0hOSVBTJTIwJTIwMjAwMzIlMjAyMDA0MTRBUDY3MjM)
  }
// 第二步编码：使用utf-8格式进行编码
const utf8Encode = (string) => {
  //string （'003120201023CHNIPS%20%2020032%20200414AP6723%2023%2'）
  string = string.replace(/\r\n/g, '\n') //回车和换行统一替换成 \n
  let utftext = ''
  for (let n = 0; n < string.length; n++) {
    let c = string.charCodeAt(n) // 当前位置Unicode(十进制的)
    if (c < 128) { // 1个字节
      utftext += String.fromCharCode(c)
       //再转回codecfr（'003120201023CHNIPS%20%2020032%20200414AP6723%2023%2'）
    } else if ((c > 127) && (c < 2048)) { //2个字节
      utftext += String.fromCharCode((c >> 6) | 192)
      utftext += String.fromCharCode((c & 63) | 128)
    } else {//3个字节
      utftext += String.fromCharCode((c >> 12) | 224)
      utftext += String.fromCharCode(((c >> 6) & 63) | 128)
      utftext += String.fromCharCode((c & 63) | 128)
    }
  }
  return utftext
}
```



## 点击添加的过程

添加componentSelector的index -》判断是否有targetMachine 有的话对应编辑或mes-》 没有跳转selector的index -》现根据是否有product显示productSelector -》再根据是否有template显示templateSelector

productSelector 遍历productsGroupByPosition分组中的product -》点击product 调用configurator中的ClearProduct或SelectProduct清空或更新主要配置数据

主要配置数据包括

```js
updateProductConfig
updateProductDefine
updateTemplate
updateProduct
updateProductConfigSnap
updateProductRule
updateProductSave
updateSoftwareDefine
updateComponentList
```

核心处理方法

```js
  SelectProduct: async ({ dispatch, commit, state }, product) => {
    commit('updateProduct', product)  //更新product
    commit('startLoadProductSelection')
    let resPD, resSD, resConfig, resRuleGetter
    // 将util的index中的类的实现，挨个实现一遍
    try {
      [resPD, resSD, resConfig, resRuleGetter] = await Promise.all([
        api.getProductDefineByProduct(product),
        api.getSoftwareDefineByProduct(product),
        api.newProductConfig(product),
        api.newProductRule(product),
      ])
      commit('updateProductDefine', resPD)  //ProductDefine实现
      commit('updateSoftwareDefine', resSD) //SoftwareDefine实现
      commit('updateProductConfig', resConfig) 
        //ProductConfig实现 挂到了window._Config_productConfig 上通过getConfig方法返回
      commit('updateProductConfigSnap', api.getConfigSnap()) 
        //返回window._Config_productConfig的Object.assign的拷贝 但是没有深拷贝
      commit('updateProductRule', resRuleGetter) // productRule构造函数的实现
      // Loading ps
      commit('startLoadProductSave') 
      let getter = await api.newProductSave(state.productConfigSnap)
      let productSave = getter.getProductSave()
      // 这里先实现ProductSave挂到了window._Config_productSave
      // 然后通过getProductSave 返回
      try {
        // 刷新价格然后再更新productSave
        await productSave.LoadPrice()
        commit('updateProductSave', getter)
         // 这里调用RefreshProductConfig
        dispatch('RefreshProductConfig')
      } catch (error) {
        dispatch('SendError', error, { root: true })
      }
      finally { commit('finishLoadProductSave') }
      // await dispatch('LoadingProductSave')
    }
    catch (error) {
      dispatch('SendError', error, { root: true })
    }
    finally {
      commit('finishLoadProductSelection')
    }
  },
```

LoadPrice方法-》通过查t_def_component_special_discount表 分别更新fcSpecialDiscountList（折扣数据列表目前没有数据）通过查t_def_component_listprice表 分别更新hwFCMapList（硬件价格map列表），swFCMapList（软件价格map列表）

```js
 // 此方法选择机型会调用一次，进入选择器后的productSummary监视productConfigSnap变化一进来也会调用一遍
RefreshProductConfig: ({ dispatch, commit, state }, checkOrWait) => {
    // edit machine will be error, because productConfigSnap will update, but productSave is null
    if (state.productSave === undefined) return
    if (!checkOrWait) {
       // 添加凭证
      commit('addRefreshWork')
    }
    if (state.refreshWorks.length) {
      if (state.refreshWorkLoader) {
        setTimeout(() => {
            // 就是自己调用自己一下
          dispatch('RefreshProductConfig', true)
        }, 5);
        return
      }
      commit('startLoadRefresh')
       // 在删除凭证
      commit('doRefreshWork')
      //----------------------------------------核心代码------------------------------------------
       // 获取productSave
      let productSave = state.productSave.getProductSave()
       // 更新productSave内部的productConfig
      productSave.UpdateConfig(state.productConfigSnap)
       // 加载选配的全部配件信息
      productSave.LoadComponents()
        .then(components => {
          // 更新state.componentList  componentList展现在配置概览
          commit('updateComponentList', components)
        })
        .catch(error => {
          console.error(error)
          dispatch('SendError', `missing info of FCCode`, { root: true })
        })
        .finally(() => {
          commit('finishLoadRefresh')
          dispatch('RefreshProductConfig', true)
        })
    }
  },
```

LoadComponents 方法-》调用loadHW和loadSW方法loadHW-》以cpu为例 ：调用packCPUComponents-》调用通用方法

> packHWComponent：内部方法 将 FC 和 Quantity 查价格表和折扣表，打包返回一个 包含价格和折扣信息的对象；找不到返回false

packHWComponent传参this.productConfig.cpuFC 和 this.productConfig.cpuQuantity（fccode和数量）

cpuFC-》CPUMemory.vue中prepares初始化方法中-》调用productDefine.ParseCPU方法传入targetMachine.components-》通过整个CPUList（库中所有的cup）查找对应的fccode返回包装好的数据:

```js
conf{ selection, cpuAct}   //selection ->是正常cpu数据 cpuAct->是激活码数据 
this.selCPUComponent = cpuInfo.selection.component;
this.selCPUCount = cpuInfo.selection.quantity;
```

prepares方法最后调用saveConfig-》调用productConfig.SaveCPUInfo方法传入selCPUComponent和selCPUCount和selCPUActivate

```js
SaveCPUInfo(cpuFC, cpuQuantity, cpuActivated) {  // 进行对应的赋值操作
    this.cpuFC = cpuFC; // CPU fccode
    this.cpuQuantity = cpuQuantity; // 数量
    this.cpuActivated = cpuActivated; //激活的CPU数量 cpuInfo.cpuAct.quantity获取来的
    this.RefreshDescription();
  }
```

通过fccode找hwFCMapList的最新数据返回cpu的component

LoadComponents 方法-》将所有的当前机器配置的的component返回成数组并在需要的每一项中添加标记-》添加componentList中

productSummary中的配置预览数据就由componentList而来

## ProductDefine类

> 说明 ：产品定义 包含内部可选部件的集合（就是可以配置的选项）

属性：

> 将所有当前服务器数据和可配置项挂载上面

方法：

## ProductConfig类

> 说明 ：产品的用户配置的集合（选配清单）

属性：

>基础数据与ProductDefine一样有机器的数据和各个部件的配置列表, 多了单独挂载当前已配置的各项部件数据，比如cpuFC，cpuQuantity，cpuActivated

方法：

## ProductSave类

属性：

>有根据FCcode生成的硬件和软件列表（hwFCMapList，swFCMapList）和折扣信息列表（fcSpecialDiscountList） 用于更新价格等，包含最新的productConfig实例对象

方法：

- 以packCPUComponents 为例   packxxx Components方法将对应的productConfig已选择的部件进行打包返回

```js
 let component = this.packHWComponent(this.productConfig.cpuFC, this.productConfig.cpuQuantity) 
 // 将productConfig 中已选择的cpu fc 和 quantity 进行打包 
```

- packBareboneComponents   加载产品默认带的部件 this.productConfig.bareboneList 进行打包 返回



## SoftwareDefine类

> 说明 ：软件的集合

属性:

>有根据软件属性进行细分的软件列表：a6pList，hpo，modeltype（机器型号），osList（操作系统软件列表），swList，swmaList（维保）

方法：

## RuleParser规则构造函数

>说明 ：解析.rule 文件 ， 进行规则检查

属性：

> objs : 用来进行规则检查的数据判断 见 symbols.js
>
> yy

方法：

> checkSem
>
> match       matchRules(className, group)  //规则检查
>
> parseError
>

## productRule.js理解

```js
var rule = (function() {
    var parser = {...}
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
})();
export default rule;
// rule是 Parser实例 Parser的原型对象是parser, rule实例可以调用parser的方法
```

productSummary的主要校验规则方法checkConfig-》this.productRuleParser.match("Server", "*")-》调用matchRules方法

### matchRules规则检查函数

```js
 function matchRules(className, group) {
    var rc = true;
    var cls = findSymbol(stack.top(), [className], [[]]);  //findSymbol根据名字返回对应的数据类似obj[name]
     //cls  {obj:[{...},reles:(24)[{...}...],symbols:(33)[{...}]}
    var errMsg = [];
    for (var j in cls.objs) {
      let obj = cls.objs[j];  // obj
      let fun = newFunCall('convert', [newDeRef(obj)]);
        //返回一个多层嵌套的对象 {name: "convert",ntype: 22,symlist: [{…}]} 数字是预置好的
        //symlist[0] :{ntype: 36,val: 就是obj }
      exec(fun);
      errMsg.push(...matchSubjectRules(obj, true));
      for (var i in cls.rules) {
        var rule = cls.rules[i];
        context.symbols.errMsg = '';
        if (group == '*' || rule.group.match(group) != null) {
          let v = execRule(rule, obj);
          if (!v) {
            errMsg.push(context.symbols.errMsg); //这里把错误信息放进去 看到这context为什么变
          }
        }
      }
    }
    return {
      errList: errMsg,
      appendList: context.symbols.server.extensions,
    };
  }

```

### parse初始化函数（TODO：）

```js

```







## CFR

### line类

new 的时候传入length 生成对应长度的空格字符串，保存在实例对象的words中

#### AutoLength

参数1 targetString 参数2length 根据设定的长度返回字符串 ，超过目标字符串的长度后面补空格 ，少于的slice截取

---




### 导出过程 

> 正常机器使用直接使用cfr.js  而mes机器使用mes文件夹下的index.js再调用cfr.js

ParseMachine方法传入machine-》



### ForceUpdate(更新)

cfrString （cfr字符串）-》/n换行符截取成数组-》lines-》去掉05和06开头的元素，-》去掉98行和后面的（尾部）-》new Line(311)生成00行对象-00Line》lines[_00LineIndex]赋值 给`_00Line`-》将00行的时间更新-》以03行_03LineIndex为界将lines数组分割为prepend 和append-》从新生成三个05行-》从新拼接新的lines -》 调用GenCheckSum方法更新底部合计-》98行：7个字符 98 后面跟lines.length+1 -》99行：7个字符 99 后面跟合计的编码结果   -》最后 return lines.join('\n')

#### GenCheckSum

```js
static GenCheckSum(lines) {
    let footer = []
    let _98Line = new Line(7)
    _98Line.WriteStrAtIndex('98', '0')
    _98Line.WriteStrBeforeEnd(lines.length + 1 + '')
    footer.push(_98Line.words)
    let _99Line = new Line(12)
    _99Line.WriteStrBeforeEnd(CheckSumLines(lines.concat(footer)) + '')//合计的编码结果
    _99Line.WriteStrAtIndex('99', '0')
    footer.push(_99Line.words) 
    return footer
  }
```

##### CheckSumLines

传入lines-》设置checksum合计为0 -》遍历lines-》使用calcLine相加每行的编码后的合计-》checksum.toString(2)转化为2进制-》判断转化后的字符串是否超过32位-》超过就-》从后向前截取32位-》转为位数字赋值checksum-》返回checksum

##### calcLine

参1：当前行的字符串line，参2：checksum -》遍历通过array.form返回line的ASCII码的数组bytesList-》bytesList每四个为一组进行遍历-》使用GetHash返回对应的自定义码hashCode-》mask初始值为16777216-》 checksum += mask * hashCode-》mask /= 256

```js
 while (true) {
    let mask = 16777216
    let x = bytesList.splice(0, 4) //每四个为一组
    if (x.length === 0) { break } //分不了 就退出循环
    x.forEach(code => {
      let hashCode = GetHash(code) // 获取对应码
      checksum += mask * hashCode; //一直累加
      mask /= 256; //每个分组里*的mask是不断/256减少的
    })
  }
```

##### GetHash方法

创建一个ASCIICODETABLE（ASCIICODE 自定义hash对照表 ） -》以奇数偶数的方式区分出key value -》GetHash方法中传入ASCIIcode 和index 默认从0开始-》使用递归的方式进行遍历ASCIICODEKEY-》直到找到对应的ASCIIcode-》返回对应的ASCIIVALUE（自定义的数字）

>0x20 是16进制的数字32，在js中可以直接用0x20 表示32

## 规格检查

各个部件内部都实现了saveConfig 方法 ，每个部件的值发生改变将触发saveConfig方法

```js
  saveConfig() {
      let svr = this.productRuleParser.objs.server; 
      let readyIOList = this.selIOComponents
        .filter(v => v.component && v.count)
        .map(v => ({
          FCCode: v.component.FCCode,
          Quantity: v.count
        })); // 获取{"FCCode":"9009-42A","Quantity":1} 形式的已选部件列表
      this.productConfig.SaveInternalPCIList(readyIOList); // 保存productConfig对应的list中
      svr.selIOComponents = this.selIOComponents.filter(   // 全数据保存到productRuleParser.objs.server中
        v => v.component && v.count
      );
      this.CreateSnap(); //赋值productConfigSnap
    }
	//规则检查器对象
     productRuleParser: function() {
      return this.productRule && this.productRule.getRuleParser();
    }
```

productSummary组件中 监听productConfigSnap变化触发checkConfig方法

```js
productConfigSnap(v, old) {
      this.checkConfig();
      this.RefreshProductConfig();
      this.calcExtendDesc();
    },
```

checkConfigf调用productRuleParser.match 进行规则检查

```js
 checkConfig() {
      let checkRes = this.productRuleParser.match("Server", "*");
      this.errList = checkRes.errList;
      this.appendList = checkRes.appendList;
      this.productConfigSnap.setAppendList(checkRes.appendList);
    },
```

match 方法

```js
/**
stack对象的stacks初始化就是 [context](上下文对象) 
context.symbols 就是rule文件的整个语法解析器对象 
也就是vue中this.productRuleParser.objs 
errMsg因为没申明，所以没有作用域，所以挂载在.rule文件解析对象的全局 ，也就是context.symbols下
stack.top() 返回 context.symbols
*/

function matchRules(className,group){
      var rc = true 
      // stack.top() => {parent: null ,symbols:就是 productRuleParser.objs}
      var cls = findSymbol(stack.top(),[className],[[]]) 
      // 返回context.symbols内部的"Server"对象
       /**
      返回数据 { objs: [{…}]，rules: [{…}]，symbols：[{…}]} 
      objs[0] 就是 productRuleParser.objs.server 也就是 rule文件中的 struct Server的实现
      rules 每个对象都是  @(Server,sr,"背板硬盘类型匹配","back"){ ...} 对应的解析好的语法对象
      symbols struct Server {****} 对象 (解析好的语法对象)
        */
      var errMsg = [];
      for(var j in cls.objs){
          let obj = cls.objs[j];
          let fun = newFunCall("convert",[newDeRef(obj)])
          // convert 对应.rule 文件中定义的convert方法    fun -》解析好的语法解析对象
          // fun { name: "convert",ntype: 22, symlist:[{ntype: 36,val: obj }]}
          exec(fun); //太深了 大概就是执行一下语法解析对象
         errMsg.push(...matchSubjectRules(obj,true))
         for(var i in cls.rules){
                var rule = cls.rules[i]; // rule 是 每个@(Server,sr,"背板硬盘类型匹配","back")的语法解析对象
                context.symbols.errMsg = "";
             // group 是 * 的意识 应该是检查所有的分组@(Server...) ，  上面的"back"就是group分组的名字
             if((group == "*")||(rule.group.match(group) != null)){
                  let v = execRule(rule,obj); //主要的规则检查在这里
                    /**
                    每个@(Server...)最后会返回一个boolean 判断这个值通不通过
                    并将context.symbols.errMsg  赋值
                     */
                  if(!v){
                      errMsg.push(context.symbols.errMsg)  
                }
            } 
       }     
      }
      return {
            errList :errMsg,
             appendList: context.symbols.server.extensions
     };
    }
```

```js
// exec(fun) 的最终执行
function eval_expr(ast){  // ast ->fun 
 switch(ast.ntype){
    case AFCALL://22
      return call(ast.name,ast.symlist) 
         //{names: (2) ["sr", "checking"],ntype: 24,offs: (2) [Array(0), Array(0)]}
 }

```

```js
function execRule(r,obj){
  let dumfun = newFun("dumy_function",[newRef(r.arg)],r.vdl,r.sl);
   //{args: [{…}],body: (2) [{…}, {…}],name: "dumy_function",ntype: 1,vdl: []}
  let funCall = newFunCall("dumy_function",[newDeRef(obj)])
	//{name: "dumy_function",ntype: 22,symlist: [{…}]}
  updateSymbol(stack.top(),["dumy_function"],dumfun,true,[[]])
  return exec(funCall)
}
```

